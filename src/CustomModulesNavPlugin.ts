import { DeclarationReflection, NavigationItem, ReflectionKind } from 'typedoc';
import { Component, RendererComponent } from "typedoc/dist/lib/output/components";
import { RendererEvent, PageEvent } from 'typedoc/dist/lib/output/events';

/**
 * A plugin that exposes the navigation structure of the documentation
 * to the rendered templates.
 *
 * The navigation structure is generated using the current themes
 * [[BaseTheme.getNavigation]] function. This plugins takes care that the navigation
 * is updated and passed to the render context.
 */
@Component({name: 'navigation'})
export class CustomModulesNavPlugin extends RendererComponent {
    /**
     * The navigation structure generated by the current theme.
     */
    navigation!: NavigationItem;

    /**
     * Compile a map of project-level block declarations. Any pages that
     * render a declaration in this map should include the list of project-level
     * modules.
     */
    unmoduledBlockDeclarations: {[id: string]: DeclarationReflection} = {};

    /**
     * Create a new NavigationPlugin instance.
     */
    initialize() {
        this.listenTo(this.owner, {
            [RendererEvent.BEGIN]: this.onBeginRenderer,
            [PageEvent.BEGIN]:     this.onBeginPage
        });
    }

    /**
     * Triggered before the renderer starts rendering a project.
     *
     * @param event  An event object describing the current render operation.
     */
    private onBeginRenderer(event: RendererEvent) {
        this.navigation = this.owner.theme!.getNavigation(event.project);

        if (event.project.children) {
            event.project.children.forEach((child: DeclarationReflection) => {
                if (child.kindOf(ReflectionKind.ClassOrInterface)) {
                    this.unmoduledBlockDeclarations[child.id] = child;
                }
            });
        }
    }

    /**
     * Triggered before a document will be rendered.
     *
     * @param page  An event object describing the current render operation.
     */
    private onBeginPage(page: PageEvent) {
        const currentItems: NavigationItem[] = [];

        const updateItem = (item: NavigationItem) => {
            item.isCurrent = false;
            item.isInPath  = false;
            item.isVisible = item.isGlobals || this.unmoduledBlockDeclarations.hasOwnProperty(page.model.id);

            if (item.url === page.url || (item.dedicatedUrls && item.dedicatedUrls.includes(page.url))) {
                currentItems.push(item);
            }

            if (item.children) {
                item.children.forEach((child) => updateItem(child));
            }
        };
        updateItem(this.navigation);

        currentItems.forEach((item: NavigationItem | undefined) => {
            item!.isCurrent = true;

            let depth = item!.isGlobals ? -1 : 0;
            let count = 1;
            while (item) {
                item.isInPath  = true;
                item.isVisible = true;

                count += 1;
                depth += 1;
                if (item.children) {
                    count += item.children.length;
                    if (depth < 2 || count < 30) {
                        item.children.forEach((child) => {
                            child.isVisible = true;
                        });
                    }
                }

                item = item.parent;
            }
        });

        page.navigation = this.navigation;
    }
}
